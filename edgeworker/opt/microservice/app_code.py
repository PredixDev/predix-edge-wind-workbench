from edgeworker import Worker, monitor_worker
import json
import os
import sys

class App_MgrWorker(Worker):
    """Edgeworker based app for use with simulink pipeline but it could be
       easily extended to support other use cases. Its function is to
       initialize the Redis environment and to setup some monitoring functions.

       Initilization of subsystem state, DB state (values that can be written to
       by multiple sunsystems) and parameters. It also has the capability to
       initialize values that might be part of a dependency loop.

       The initilaization comes from one of two files. First, it looks for
       existance of the initilization json file named `custom_ss_init.json`. If
       it exists it will be read and returned. Else it will attempt to read
       `default_ss_init.json` which is created at build time and will probably not
       have the initialization desired.
       The idea is that the `custom_ss_init.json` file will be created by a script
       in Simulink or it can be a renamed and modified version of the
       automatically generated `default_ss_init.json`.

       Monitoring is currently done on the pub/sub channels that feed or are
       generated by the Simulink subsystems. It would not be difficult to add
       other channels for monitoring to the `custom_ss_init.json` file."""

    def initialization(self):
        self.info("App_MgrWorker starting")
        # read in default_ss_init.json file
        self.controlms_obj = self.get_init_json_from_file()
        # Setup heartbeat registry
        self.heartbeat_scan_registry = {}
        # Check and initialize these
        self.state_init()
        self.db_init()
        self.dependance_loops_init()
        self.heartbeat_init()

    def state_init(self):
        """Initializes state stored in Redis if it isn't already there"""
        #TODO: If a new state value is added to an existing ss this will not initialize
        #      it. Should probably look to see if the structure is the same and if not
        #      warn someone.
        state_init_obj =  self.controlms_obj.get('controlms',{}).get('state_init',{})
        for ss_alias,state in state_init_obj.iteritems():
            output_state_object = {}
            for state_name,state_value in state.iteritems():
                output_state_object[state_name] = state_value
            # Nameing convention is <subsystem_name>.state.data  i.e sys1.state.data
            state_init_key = "{}.state.data".format(ss_alias)
            if not self.exists(state_init_key):
                self.set(state_init_key,output_state_object)

    def db_init(self):
        """Initializes DB stored in Redis if it isn't already there"""
        db_init_obj =  self.controlms_obj.get('controlms',{}).get('db_init',{})
        for db_name,db_value in db_init_obj.iteritems():
            if not self.exists(db_name):
                self.set(db_name,db_value)

    def dependance_loops_init(self):
        """Initializes dependance loops in Redis if it isn't already there"""
        #TODO: If a dependance loops value is added to an existing ss this will not initialize
        #      it. Should probably look to see if the structure is the same and if not
        #      warn someone.
        dependance_loops_init_obj =  self.controlms_obj.get('controlms',{}).get('dependance_loops_init',{})
        for key,obj_props in dependance_loops_init_obj.iteritems():
            if not self.exists(key):
                self.set(key,obj_props)

    def extern_param_init(self):
        """Initializes extern parameters in Redis if it isn't already there"""
        global_key = 'global.params.data'
        #TODO: If a extern parameters value is added to an existing ss this will not initialize
        #      it. Should probably look to see if the structure is the same and if not
        #      warn someone.
        extern_param_init_obj =  self.controlms_obj.get('controlms',{}).get('extern_param_init',{})
        if len(extern_param_init_obj) > 0:
            if not self.exists(global_key):
                self.set(global_key,extern_param_init_obj)

    def heartbeat_init(self):
        """Initializes the heartbeat detection mechanism. This will provide a
           channel health status value stored in the Redis database. The status
           key has this pattern `health.<channel_string>`. For example
           `health.fromplant.sys1.data`. The status is one of these `starting`,
           `up` or `down`. The status will be monitored even after it is `down`
           so you may see it bounce around if `rate` is not set correctly."""
        heartbeats_init_obj =  self.controlms_obj.get('controlms',{}).get('heartbeats_init',{})
        for channel,properties in heartbeats_init_obj.iteritems():
            # Register heartbeat
            properties['count'] = 0
            channel_health_key = 'health.' + channel
            properties['channel_health_key'] = channel_health_key
            properties['last_state'] = 'starting'
            self.sets(channel_health_key,'starting')
            self.heartbeat_scan_registry[channel] = properties
            # Subscribe to channel
            self.add_subscription(channel)
        # Call the timer function every second
        self.setup_timer(1,self.worker_timer)
        self.start_timer()

    def worker_timer(self):
        """Heartbeat for pub/sub traffic. This function is called (as a callback)
           by the `self.setup_timer(1,self.worker_timer)` in `heartbeat_init`
           at a regular rate (once a second). Registered
           channels have a counter assigned. This counter is incremented here
           and cleared when an publish event is received. If the counter ever
           exceeds 2 times the channels defined rate (found in the channels
           heartbeat_init properties of the either the `custom_ss_init.json` file,
           if defined, or the autogenerated `default_ss_init.json` file)."""
        for channel,properties in self.heartbeat_scan_registry.iteritems():
            count = properties['count']
            rate = properties['rate']
            count = count + 1
            properties['count'] = count
            channel_health_key = properties['channel_health_key']
            last_state = properties['last_state']
            if count > (2 * rate):
                if (last_state != 'down'):
                    self.warning("Channel {} is down".format(channel))
                    properties['last_state'] = 'down'
                    self.sets(channel_health_key,'down')
            else:
                if (last_state != 'up'):
                    self.info("Channel {} is up".format(channel))
                    properties['last_state'] = 'up'
                    self.sets(channel_health_key,'up')

    def work(self,channel,in_object):
        """Called when a published event for one of the channel we are
           interested in is received."""
        properties = self.heartbeat_scan_registry.get(channel,None)
        if properties:
            # Reset counter
            properties['count'] = 0

    def get_json_file(self,filename):
        """Given the name of a JSON file return an object otherwise print error
           and exit"""
        if os.path.isfile(filename):
            with open(filename, 'r') as handle:
                json_obj = json.load(handle)
            return(json_obj)
        else:
            self.error("ERROR: Get JSON file found that the filename given {} is not a file".format(filename))
            sys.exit(1)

    def get_init_json_from_file(self):
        """Gets the initilaization json from one of two files. First, it looks for
           existance of the initilization json file named `custom_ss_init.json`. If
           it exists it will be read and returned. Else it will attempt to read
           `default_ss_init.json` which is created at build time and will probably not
           have the initialization desired.
           The idea is that the `custom_ss_init.json` file will be created by a script
           in Simulink or it can be a renamed and modified version of the
           automatically generated `default_ss_init.json`."""
        if os.path.exists('custom_ss_init.json'):
            return(self.get_json_file('custom_ss_init.json'))
        else:
            return(self.get_json_file('default_ss_init.json'))

if __name__ == '__main__':
    # Create and start the worker
    app_mgr_worker = App_MgrWorker()
    # Worker started and now monitor it
    monitor_worker(app_mgr_worker)
