import sys
import signal
import time
from threading import Event
from edge_timer import PTimer
from edge_log import Log
from cdp_interface import CDPInterface
#from redis_CDP import RedisInterface as CDPInterface



class Worker(Log,PTimer,CDPInterface):
    ''' Worker class is an abstract class that is not intended to be instanced
    but to be extended through inheritance.

    Note it is important that the order of the inherited classes needs to stay
    in this order(Log,PTimer,CDPInterface)

    Worker Base Container - The strategy is to import 'edgeworker' and create a
    class that extends it through inheritance. The extended class needs to
    implement the initialization and work methods.

    Using this approach is perhaps the simplest method to developing an
    App / micro-service in Python.

    The list of inherited methods can be found in the EDGEWORKER.md

    This strategy is also leveraged by the Edge Simulink Pipeline. In that workflow
    the class that extends the Worker class below also extends the Edge Simulink
    Service class through multiple inheritance. The result is that the extended
    class has access to both the CDP and the Edge Simulink Services. The tool
    CreateConnect (which is part of the Edge Simulink Pipeline) can autogenerated
    this class extension code.
    '''

    def __init__(self):
        super(Worker, self).__init__()
        print( "INFO: Listener client started [MSGID:LISTENER_STARTED]")
        self._worker_term_event = Event()
        print( "INFO: Worker Base Class Init")
        self.initialization()

    def terminate(self):
        '''Call this if you want to exit the worker'''
        self.cancel_timer()
        self.cancel_cdp()
        self._worker_term_event.set()

    def is_terminated(self):
        '''Indicates that terminate has been called '''
        return self._worker_term_event.is_set()

    def get_signal_handler(self):
        '''Returns the signal handler that, once registered, will call terminate
        when SIGTERM is raised'''
        def signal_handler(signum, frame):
            self.info("Subsystem was told to terminate...")
            self.terminate()
        return signal_handler

    def initialization(self):
        '''Method that is called once when the extended class is instanced.
        It is recommended that reading of environment variables, subscriptions,
        instancing of PTimers and other initialization actvities happen in the
        implementation of this method'''
        print( "INFO: Worker.initialization() called which shouldn't happen.")
        print( "INFO: This should be overwritten by a child class")

    def work(self,channel,in_object):
        '''Abstract Method designed to be implemented by the class extending
        Worker.  This will be called by the CDP when a subscrided topic is
        received'''
        print( "INFO: Worker.work() called which shouldn't happen.")
        print( "INF: This should be overwritten by a child class")


def monitor_worker(worker):
    ''' Given the worker instance registers a signal_handler that on SIGTERM
    will terminate the pubsub listening thread, loop and wait for thread to
    terminate and finnally join the thread.
    '''
    # Signal handler for SIGTERM
    signal_handler = worker.get_signal_handler()
    signal.signal(signal.SIGTERM, signal_handler)

    print( "INFO: Listener worker started [MSGID:LISTENER_STARTED]")
    # Wait for the thread to terminate
    #while not worker.is_terminated():
    while True:
        time.sleep(0.2) # wait here for worker to terminate
    print( "INFO: Waiting for worker thread...")
    #worker.join()
    print( "INFO: Listener worker terminated.")


