import threading
import json
import os
import sys
import signal
import time
import pycdp
import traceback
from config_helper import *

class CDPInterface(threading.Thread):
    def __init__(self):
        super(CDPInterface, self).__init__()
        cdp_config = self.get_cdp_config()
        self._term_event = threading.Event()

        self.daemon = True # so we can kill it with CTRL-C
        # Create the CDP object and a registry entry for a REDIS transport
        self.cdp = pycdp.pycdp(cdp_config, log_level=pycdp.log_debug, log_id="test")
        self.in_channels = []

    def publish(self, out_channel, json_obj):
        json_str = json.dumps(json_obj)
        self.cdp.pub(out_channel, json_str)

    def subscribe(self,channels_list):
        for chan in channels_list:
            self.cdp.sub(chan, self.sub_handler)

    def set(self, key, json_obj):
        json_str = json.dumps(json_obj)
        self.cdp.set(key, json_str)

    def get(self, key):
        (status, m) = self.cdp.get(key)
        if status != 200:
            return None

        try:
            json_obj = json.loads(m)
            return(json_obj)
        except:
            print ("INFO: CDP Error Get() exception:", traceback.format_exc())
        return None

    def exists(self, key):
        (s, m) = self.cdp.get("/exists?key=%s" % (key))
        if s != 200:
            print("INFO: CDP query exists not successful--code: [%d]  key: %s" % (s, key))
            return False
        else:
            #print >>sys.stderr, "CDP: query exists code: [%d],  key: %s, message %s" % (s, key, m)
            if int(m) == 1:
                return True
            return False

    def sets(self, key, strval):
        self.cdp.set(key, strval)

    def gets(self, key):
        (s, m) = self.cdp.get(key)
        return m

    def keys(self, key_pattern):
        ## Returns of matching keys
        (s,m) = self.cdp.get("/keys?pattern=%s" %(key_pattern))
        key_list = json.loads(m)
        return key_list

    def append_in_channel(self, channel):
        self.in_channels.append(channel)
        print("INFO: Subscription to %s was added" % channel)
        s = self.cdp.sub(channel, self.sub_handler)
        print("INFO: Channel subsrciption code ", s)

    def add_subscription(self, channel):
        self.append_in_channel(channel)

    def cancel_cdp(self):
        self._term_event.set()

    def cdp_is_terminated(self):
        return self._term_event.is_set()

    def sub_handler(self, source, channel, raw_message):
        try:
            # Message accidently encodes the b' as a byte string, strip it
            msg = raw_message[2:-1]
            json_obj = json.loads(msg)  # need better error handling
        except:
            print("ERROR: On channel %s json.loads %s" % (channel, traceback.format_exc()))
            return

        try:
            print("DEBUG", channel, json_obj)
            # Notice Calls the derived class version of work
            self.work(channel, json_obj)
        except:
            print("DEBUG: Exception calling work", traceback.format_exc())

    def run(self):
        # This gets called by a call to threads start routine
        while not self.cdp_is_terminated():
            time.sleep(0.01)  # be nice to the system :)
        print("INFO: run thread terminated")


    def external_cdp_config(self):
        # check Environment variable CDP_CONFIG first
        # if not exist, try to load config.json file
        # if not successful, return None for get_cdp_config() processing
        cdp_config = os.getenv('CDP_CONFIG', None)
        if cdp_config == None:
            try:
                cdp_config_path = os.getenv("CDP_CONFIG_PATH", 'future_config.json')
                #TODOLIST: need to be able to handle future_config
                cdp_config_path = get_config_path(cdp_config_path)
                with open (cdp_config_path) as cdp_config_file:
                    cdp_config = json.load(cdp_config_file)
            except:
                print("INFO: could not load CDP_CONFIG from %s, use default cdp_config." % cdp_config_path)
                return None
        return cdp_config

    def get_cdp_config(self):
        cdp_config = self.external_cdp_config()
        if cdp_config == None:
            cdp_config = json.dumps({
                  "info":{
                    "file_version":1.0
                  },
                  "config":{
                    "plane1":{
                    "transport_addr":"redis://edgeservices_cdp_redis"
                    },
                    "plane2":{
                    "transport_addr":"mqtt-tcp://edgeservices_cdp_mqtt"
                    }
                  },
                  "mapping":[
                    ["plane1",12, ".*", ""],
                    ["plane2",3, ".*", ""]
                  ]
            })
        return cdp_config
