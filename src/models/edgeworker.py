import sys
import signal
import time
from threading import Event
from edge_timer import PTimer
from edge_log import Log
from cdp_interface import CDPInterface
#from redis_CDP import RedisInterface as CDPInterface



class Worker(Log,PTimer,CDPInterface):
    ''' Worker class is an abstract class that is not intended to be instanced
    but to be extended through inheritance.

    Note it is important that the order of the inherited classes needs to stay
    in this order(Log,PTimer,CDPInterface)

    Worker Base Container - The strategy is to import 'edgeworker' and create a
    class that extends it through inheritance. The extended class needs to
    implement the initialization and work methods.

    Using this approach is perhaps the simplest method to developing an
    App / micro-service in Python.

    The list of inherited methods can be found in the EDGEWORKER.md

    This strategy is also leveraged by the Edge Simulink Pipeline. In that workflow
    the class that extends the Worker class below also extends the Edge Simulink
    Service class through multiple inheritance. The result is that the extended
    class has access to both the CDP and the Edge Simulink Services. The tool
    CreateConnect (which is part of the Edge Simulink Pipeline) can autogenerated
    this class extension code.
    '''

    def __init__(self):
        super(Worker, self).__init__()
        print >>sys.stderr,"INFO: Listener client started [MSGID:LISTENER_STARTED]"
        self._worker_term_event = Event()
        print >>sys.stderr,"INFO: Worker Base Class Init"
        self.initialization()

    def terminate(self):
        '''Call this if you want to exit the worker'''
        self.cancel_timer()
        self.cancel_cdp()
        self._worker_term_event.set()

    def is_terminated(self):
        '''Indicates that terminate has been called '''
        return self._worker_term_event.is_set()

    def get_signal_handler(self):
        '''Returns the signal handler that, once registered, will call terminate
        when SIGTERM is raised'''
        def signal_handler(signum, frame):
            self.info("Subsystem was told to terminate...")
            self.terminate()
        return signal_handler

    def initialization(self):
        '''Method that is called once when the extended class is instanced.
        It is recommended that reading of environment variables, subscriptions,
        instancing of PTimers and other initialization actvities happen in the
        implementation of this method'''
        print >>sys.stderr,"INFO: Worker.initialization() called which shouldn't happen."
        print >>sys.stderr,"INFO: This should be overwritten by a child class"

    def work(self,channel,in_object):
        '''Abstract Method designed to be implemented by the class extending
        Worker.  This will be called by the CDP when a subscrided topic is
        received'''
        print >>sys.stderr,"INFO: Worker.work() called which shouldn't happen."
        print >>sys.stderr,"INF: This should be overwritten by a child class"


def worker_monitor(worker):
    ''' Given the worker instance registers a signal_handler that on SIGTERM
    will terminate the pubsub listening thread, loop and wait for thread to
    terminate and finnally join the thread.
    '''
    # Signal handler for SIGTERM
    signal_handler = worker.get_signal_handler()
    signal.signal(signal.SIGTERM, signal_handler)

    print >>sys.stderr,"INFO: Listener worker started [MSGID:LISTENER_STARTED]"
    # Wait for the thread to terminate
    #while not worker.is_terminated():
    while True:
        time.sleep(0.2) # wait here for worker to terminate
    print >>sys.stderr,"INFO: Waiting for worker thread..."
    #worker.join()
    print >>sys.stderr,"INFO: Listener worker terminated."


######################################################################
#### Testing
#### Need redis or what ever CDP you are using available
######################################################################
if __name__ == "__main__":
    ## SSX is a dummy Simulink class
    ## you may want to set the REDIS_PY_IP env var
    #  on Mac use setnv REDIS_PY_IP 127.0.0.1
    class SSX(object):
        def __init__(self):
            super(SSX, self).__init__()
            print "SSX has initialized"

        def set_SSX_value_a(self,a):
            print "SSX >a< set",a
            self.a = a

        def set_SSX_value_b(self,b):
            print "SSX >a< set",b
            self.b = b

        def step(self):
            print "SSX step called"
            self.x = self.a + self.b

        def get_SSX_value_x(self):
            return(self.x)

        def terminate(self):
            print "SSX has been terminated"
            # call the terminate function of the parent
            super(SSX,self).terminate()

    ## Very simple micro-service
    class TestWorkerA(SSX,Worker):
        def initialization(self):
            print "TestWorkerA initialization"
            self.in_channel = None
            self.in_object = None

        def work(self,channel,in_object):
            print "TestWorkerA on channel",channel,"recieved",in_object
            self.in_channel = channel
            self.in_object = in_object

    ## Micro-service that is similar to those used in the Simulink pipeline
    class TestWorkerB(SSX,Worker):
        def initialization(self):
            print "TestWorkerB initialization"
            self.in_channel = None
            self.in_object = None

        def work(self,channel,in_object):
            kv_object = self.get('ssx_test_in_a')
            self.set_SSX_value_a(kv_object['a'])
            self.set_SSX_value_b(in_object['b'])
            self.step()
            out_object = {}
            out_object['x'] = self.get_SSX_value_x()
            self.set('ssx_test_out_x',out_object)

    ## Micro-service to test the perpetual timer
    class TestWorkerC(Worker):
        def initialization(self):
            print "TestWorkerC initialization"
            self.count = 0
            time_in_seconds = 1
            self.setup_timer(time_in_seconds,self.worker_timer)
            self.start_timer()

        def work(self,channel,in_object):
            print "No one will call this becuase there are no subscriptions"

        def worker_timer(self):
            self.count = self.count + 1


    # Test edgeworker
    twa = TestWorkerA()
    twb = TestWorkerB()

    print "******************************************************************************"
    print "TEST: pub/sub TWB -> TWA *****************************************************"
    print
    print "TWA subscribe to channel FOR_A"
    print
    twa.append_in_channel('FOR_A')
    print "TWB publish to FOR_A"
    print
    twb.publish("FOR_A",{'data':'from b'})
    print "Should see a print from TWA now"
    print
    time.sleep(0.2)
    print "Checking results"
    test_result = False
    print "in_channel",twa.in_channel,"in_object",twa.in_object
    try:
        test_result = (twa.in_channel == 'FOR_A' and twa.in_object['data'] == 'from b')
    except:
        pass
    if test_result:
        print "GOOD: Pub/sub from TWB to TWA passed"
    else:
        print "BAD: Pub/sub from TWB to TWA failed"
        exit(0)
    print
    print

    print "******************************************************************************"
    print "TEST: pub/sub TWB -> TWA wrong channel (Should fail)**************************"
    print
    print "TWA subscribe to channel FOR_A"
    print
    twa.append_in_channel('FOR_A')
    print "twb publish to FOR_XXXXXX"
    print
    twb.publish("FOR_XXXXXX",{'data':'from xxxxx'})
    print "Should not see a print from TWA now"
    print
    time.sleep(0.2)
    print "Check results"
    try:
        test_result = (twa.in_channel == 'FOR_A' and twa.in_object['data'] == 'from b')
    except:
        pass
    if test_result:
        print "GOOD: Pub/sub to wrong channel from TWB to TWA passed"
    else:
        print "BAD: Pub/sub from TWB to TWA failed"
        exit()

    print
    print "******************************************************************************"
    print "TEST: key/value TWB -> TWA ***************************************************"
    print
    print "TWB set key 'testkv' to {'data':12}"
    twb.set('testkv',{'data':12})
    print "TWA read key"
    print
    print "Received ",twa.get('testkv')
    test_object = twa.get('testkv')
    test_result = False
    try:
        test_result = (test_object['data'] == 12)
    except:
        pass
    if test_result:
        print "GOOD: K/V from TWB to TWA passed"
    else:
        print "BAD: K/V from TWB to TWA failed"
        exit()

    print "******************************************************************************"
    print "TEST: pub/sub and key/value plus Simulink proxy calculation TWA -> TWB *******"
    print
    print "TWA set key 'ssx_test_in_a' to {'a':12}"
    twa.set('ssx_test_in_a',{'a':12})
    print
    print "Setup channel in B"
    twb.append_in_channel('FOR_B')
    print
    print "Publish a {'b':2} to FOR_B"
    twa.publish('FOR_B',{'b':2})
    print
    print "Delay 0.2 seconds"
    time.sleep(0.2)
    print
    print "Get ssx_test_out_x result from k/v"
    print "Result:",twb.get('ssx_test_out_x')
    test_object = twb.get('ssx_test_out_x')
    test_result = False
    try:
        test_result = (test_object['x'] == 14)
    except:
        pass
    if test_result:
        print "GOOD: K/V from TWB to TWA passed"
    else:
        print "BAD: K/V from TWB to TWA failed"
        exit()

    print "******************************************************************************"
    print "TEST: keys function *******"
    print
    print twa.keys('*')
    print

    print "******************************************************************************"
    print "TEST: Timer function *******"
    print
    print "Instance TWC which has a 1 second timer that increases a counter by 1"
    twc = TestWorkerC()
    print
    print "Get the value of the counter"
    early_count = twc.count
    print "Early count:",early_count
    print
    print "Delay for 4 seconds"
    time.sleep(4)
    print
    print "Get the value of the counter again"
    late_count = twc.count
    print "Late count:",late_count
    print
    print "Check values"
    test_result = False
    try:
        test_result = (early_count < late_count)
    except:
        pass
    if test_result:
        print "GOOD: Timer and counter working"
    else:
        print "BAD: Counter or Timer failed"
        exit()

    twa.terminate()
    twb.terminate()
    twc.terminate()

    # Need to figure out how to test these
    #worker_monitor(twa)
    #worker_monitor(twb)
    #worker_monitor(twc)
